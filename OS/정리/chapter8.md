# A20 게이트를 활성화시켜 1MB 이상 영역에 접근해보자

## IA-32e 모드 커널과 메모리 맵

<br>

이번 장에서는 ```1) IA-32e 모드 커널을 실행하기 위해서 메모리가 64MB 이상인지``` 검사하고 ```2) IA-32e 모드 커널이 위치할 영역을 0으로 초기화```를 해주고, ```3) 1MB 이상의 메모리 주소에 정상적으로 접근할 수 있는지 확인하고 이를 위해 어떤 작업을 해야 하는지 확인``` 해볼 것이다. 

<br>

왜 1MB 이상의 메모리에 접근할 수 있어야 하는가?

현재 커널은 0x10000부터 시작하는데, 비디오 메모리가 0xA0000에 위치하여 사용 가능한 공간이 ```0xA0000 - 0x10000 = 576KB``` 정도가 된다.

커널에 기본적인 기능만 있다면 충분한 메모리 공간이지만, 우리는 다양한 기능을 추가해줄 것이기 때문에 부족하다.

따라서 MINt64 OS에서는 **커널 이미지는 0x10000에 복사시키되**, **크기가 큰 IA-32e 모드 커널은 2MB ~ 6MB 영역에 복사할 것**이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/195786345-4482353e-a9b9-44d1-a164-22988a194c72.png)

<br>

그래서 이미지는 0x10000에 올리고, IA-32e 모드 커널은 2MB에 위치되어있다.

**IA-32e 모드 커널이 위치할 영역을 0으로 초기화시켜주는 이유**는 커널은 초기화되지 않은 영역이 있을 수 있으나, 커널 **이미지**는 초기화 되지 않은 영역이 없기 때문이다.

따라서 이미지를 2MB ~ 6MB에 복사했을 때, 초기화되어 있지 않다면 0 대신 이상한 값이 참조가 될 수 있어서 실행 중 오류가 발생할 수 있다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## IA-32e 모드 커널을 위한 메모리 초기화

<br>

main.c에 1MB부터 6MB까지의 영역을 초기화 해주는 코드 추가하는 챕터

<br>

![image](https://user-images.githubusercontent.com/52172169/195790211-17ed4c35-f7fc-45ca-910a-ec2595b42077.png)

<br>

근데 MINT64 OS를 프로그램을 통해 실제 PC에(플로피 디스크)에 복사하여 실행하면 에러가 나서 종료된다.

왜냐하면 실제 PC에서는 하위 기종과의 호환성을 위해 **어드레스 라인을 비활성화**했기 때문이라고 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 1MB 어드레스와 A20 게이트

A20은 어드레스 라인의 번호를 뜻하는데, 이보다 더 중요한 내용을 가지고 있으며 시스템 포트와 BIOS 서비스를 통해 활성화 시킬 수 있다.

<br><br>

### A20 게이트의 의미와 용도
---

<br>

옛날 XT PC에서는 최대 1MB까지 접근가능했으나 AT PC가 나오면서 16MB까지 접근 가능해졌는데, XT PC에서 사용하던 프로그램이 AT PC에서 에러가 발생하게 된다.

해결방법으로 A20 게이트가 나온 것이며, **A20 게이트는 20번째 비트를 비활성화시켜 0으로 고정시켜주는 것**이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/195795139-066b61df-df18-431b-92e6-5c6f5f9e834b.png)

<br>

즉, **A20게이트가 비활성화되면 홀수 MB에는 접근할 수 없다는 것**이다.

A20 게이트가 비활성화되면 MINT64 OS입장에서는 1MB ~ 6MB 까지 초기화해줘야하는데, 0 ~ 1MB와 2 ~ 3MB, 4MB ~ 5MB만 초기화가 된다.

근데 0 ~ 1MB 영역에는 BIOS와 보호모드 커널이 사용 중인 영역으로 이 부분이 초기화되어 에러가 발생하는 것이다.

<br><br>

### A20 게이트 활성화
---

<br>

세 가지 방법이 있는데, **시스템 컨트롤 포트를 통한 활성화**, **키보드 컨트롤러를 이용한 활성화**, **BIOS 서비스를 이용한 활성화** 방법이 있다.

우리는 시스템 컨트롤 포트와 BIOS 서비스를 통해 활성화한다.

<br>

시스템 컨트롤 포트는 I/O 어드레스의 0x92에 위치하며, 포트맵 I/O 방식으로, 접근하려면 특수 명령어인 in과 out 명령어를 통해 접근한다.

아래 표는 시스템 컨트롤 포트의 각 비트의 역할을 보여준다.

<br>

![image](https://user-images.githubusercontent.com/52172169/195805116-1c6774ca-3fce-4794-93d0-3ab4e7efc9ae.png)

<br>

그래서 우리는 1번 비트만 1로 설정해주면 된다.

![image](https://user-images.githubusercontent.com/52172169/195805193-f67fd6ab-4f52-4e60-82b3-a1ad152a8a7c.png)

<br>

**BIOS로 활성화**하는 방법은 좀 더 쉬운데, BIOS 시스템 서비스 인터럽트 벡터는 0x15이며, 여기에 A20게이트 관련 기능이 있으므로 인터럽트를 호출해주면 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/195807346-d9a6e598-90be-40b0-a97e-1768491fe63a.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/195807406-c84cbb3c-cf50-4de6-9723-499fc3eac3ac.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## A20게이트 적용 및 메모리 검사

<br>

BIOS 기능을 사용하므로 보호모드로 바뀌기 전인, 부트로더 코드나 보호모드 **커널 엔트리포인트 코드에 추가**해주면 되는데, 의미상 후자에 추가한다.

또한 A20활성화 방법을 두 가지 모두 사용할 필요는 없으나, **BIOS마다 차이가 있으므로 혹시 모르니 둘 다 추가**해주며, **순서**는 BIOS 서비스로 시도 후 실패 시 시스템 컨트롤 포트로 활성화해준다.

책을 통해 **코드를 적용해주면 이제 1MB 이상의 메모리에 접근할 수 있게 된다.**

<br>

그전에 **사용 가능한 메모리의 총 용량**을 알아내야 한다.

보호모드 커널은 최대 4GB 메모리까지만 접근 가능해서, 정확하게 판단하려면 IA-32e 커널에서 확인해야 한다.

<br>

이제 **메모리를 검사**하는 방식을 정해보자면, **가장 확실한 방법은 메모리에 값을 쓰고 다시 읽어와서 비교해보는 것**이다.

물리 메모리라면 값이 쓰이겠지만, 아니라면 값이 쓰이지 않게되므로 실제 메모리 크기를 알아낼 수 있다.

검사 방법은 1MB 단위로 확인하며, 각 MB의 첫 4바이트에 0x12345678 값을 써준 뒤 비교한다.

이 코드를 **커널 엔트리 포인트 C 코드**에 추가해준다.

<br>

+ ```qemu-system-x86_64 -L . -m 32 -fda ./Disk.img -M pc -localtime;```

![image](https://user-images.githubusercontent.com/52172169/195843086-dc3be59c-cff4-4f6f-8a91-974ec4ad9f59.png)

<br>

+ ```qemu-system-x86_64 -L . -m 64 -fda ./Disk.img -M pc -localtime;```

![image](https://user-images.githubusercontent.com/52172169/195843353-c73380bd-5330-4f29-b609-542c860b2e62.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
