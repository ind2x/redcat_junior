# 라운드 로빈 스케줄러를 추가하자
## 스케줄러와 리스트

<br>

**스케줄러**는 **태스크의 순서를 정렬하여 실행 순서를 정해주는 역할**을 하는데, 정렬하는 가장 큰 이유는 **시스템 성능 향상이 목적**이다.

대표적으로 라운드 로빈 스케줄러가 있는데 라운드 로빈은 일정 시간마다 돌아가면서 공평하게 실행하는 방법이다.

멀티태스킹의 목적과 가장 부합한 알고리즘이지만, 단점은 태스크가 많아지면 전체적으로 성능이 저하된다.

그래서 라운드 로빈 알고리즘이 나왔고, 이 알고리즘을 이용한 기법에는 **멀티레벨 큐 알고리즘**과 **멀티레벨 피드백 큐 알고리즘**이 있다.

<br>

MINT64 OS에서는 우선순위를 3개의 레벨로 구분하여 부여할 것이며, 각 레벨별로 라운드 로빈을 수행하는 **멀티레벨 큐 스케줄러**를 이용할 것이다.

따라서 먼저 라운드 로빈을 구현해야 한다. 

<br>

라운드 로빈은 일정 시간마다 CPU의 소유권을 바꿔주는 알고리즘이며, 리스트라는 자료구조를 이용해서 구현해줄 것이다. 

<br>

![image](https://user-images.githubusercontent.com/52172169/202891721-b3cf365e-9884-4eb5-a001-a3c501723558.png)

<br>

리스트에 데이터를 삽입/삭제 하는 과정은 다음과 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/202892001-f405dd85-b8a0-4be1-ae42-770b2c0b0f52.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/202892008-932dfb61-d565-4c5f-982c-d2399a4a62d8.png)

<br>

Code : https://github.com/kkamagui/mint64os-examples/blob/master/source_code/chap18/02.Kernel64/Source/List.c

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 태스크 풀과 스케줄러

<br>

태스크 풀은 TCB를 모아놓은 영역을 뜻한다.

즉, 태스크 풀에는 최대 개수의 TCB가 있어야 하며, 이 공간은 최대 8MB만큼의 메모리가 필요하다.

우리 MINT64 OS에서는 이 공간을 IST 영역 이후의 공간인 8MB 이후의 영역에 할당할 것이다.

<br>

이제 태스크 풀 영역을 관리할 자료구조를 설정해줘야 한다.

자료구조에는 태스크 풀의 시작 주소, TCB의 최대 개수, 사용한 TCB 개수를 저장해줘야 한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/202892376-2440d419-752a-4ab4-b5d8-f7412ed35929.png)

<br>

태스크 풀은 초기화 함수, 할당 및 해제 함수로 구성된다.

먼저 초기화 하는 함수는 다음과 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/202892740-5be7e8c1-d7ef-4363-9446-c7ee7610dfeb.png)

<br>

TCB 최대 개수는 MINT 64 OS는 1024개까지 생성할 수 있으므로 1024개로 설정해준다.

태스크를 할당하려면 태스크 풀을 검색하여 해당 TCB가 할당된 상태인지, 해제된 상태인지 확인해야 한다.

이는 TCBPOOLMANAGER 자료구조에 있는 iAllocatedCount 필드와 TCB의 ID 값을 이용해서 확인할 수 있다.

<br>

iAllocated 값은 항상 1 이상의 값을 가지며, 이 값을 TCB가 할당될 때마다 할당된 TCB의 ID의 상위 32비트 값과 OR 연산하여 저장하고, 빈 TCB를 검색할 때 ID의 상위 32비트의 값이 0인지 확인함으로써 태스크의 할당 여부를 확인한다.

Code : https://github.com/kkamagui/mint64os-examples/blob/master/source_code/chap18/02.Kernel64/Source/Task.c

<br>

이제 라운드 로빈 스케줄러를 구현해준다. 구현 시 필요한 정보를 자료구조로 정의해준다.

<br>

![image](https://user-images.githubusercontent.com/52172169/202893275-7280d5e0-a2a1-4c21-972c-684ad372681c.png)

<br>

스케줄러는 크게 초기화 함수, 현재 수행 중인 태스크와 태스크 리스트를 관리하는 함수, 태스크 전환 함수로 구성된다.

이 부분은 p.631부터 책으로 복습하기

복습 후 요약하면 다음과 같다.

<br>

초기화 함수에서 현재 태스크를 할당받는 부분이 있는데, 이유는 우선 스케줄러 초기화 함수는 **부팅 과정에서 실행**되는데 태스크 전환 시 부팅을 진행한 태스크의 컨텍스트를 저장할 공간이 필요하기 때문에 할당받아서 실행 태스크로 설정한 것이다. (책에 설명)

<br>

![image](https://user-images.githubusercontent.com/52172169/203549269-4f7effc1-ee31-4187-8454-189e5efb7e2e.png)

<br>

그 다음 자료구조 및 관리하는 함수는 코드를 보면 이해가 가능하다.

그 다음 가장 중요한 태스크 전환하는 부분은 **두 가지**로 구분하는데, **태스크 수행 중에 태스크 전환이 일어나는 경우**와 **인터럽트에 의해 태스크 전환이 일어나는 경우**로 구분된다.

우선 **태스크 수행 중 태스크 전환**의 경우를 살펴보면 기존에 전환하던 대로 전환하는 대신 **추가되는 코드**가 있다.

다음 태스크 선별 등이 있는데 **중요한 건** 바로 **인터럽트 제어 부분**인데, 전환 도중 인터럽트가 발생하여 태스크 전환이 또 일어나게 되면 문제가 발생하게 되므로 태스크 전환 전에 **인터럽트 비활성화**를 해준 뒤 끝나면 다시 이전 인터럽트 상태를 복원시켜준다.

**인터럽트에 의한 경우**는 간단한데, 인터럽트가 발생하면 자동으로 기존 태스크 컨텍스트를 IST에 저장하므로, 전환을 위해서 기존 태스크의 컨텍스트를 가져와서 저장한 다음, 다음 태스크의 컨텍스트를 IST에 복사시킨 다음 컨텍스트 전환을 해주면 된다.

이 또한 이제 코드를 보면 바로 이해할 수 있다.

<br>

시분할 멀티태스킹을 구현해줄 것인데, 일정 시간이 지나면 이를 알려줄 신호가 필요한데 이 부분을 IRQ 0번으로 대체해 줄 것이다.

따라서 PIT 인터럽트 핸들러 함수를 새로 추가하고 IRQ 0을 ISR 함수에서 불러오도록 할 것이다.

이 부분 또한 p.637부터 복습해주는 것이 좋겠다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 빌드

<br>

```List.h, List.c``` 코드가 추가되고, ```Task.c, Task.h```에 라운드 로빈 스케줄러, 태스크 풀과 스택 풀 관련 함수, 자료구조와 매크로가 추가되었다.

그 외 여러 코드들을 수정하였다.

<br>

![image](https://user-images.githubusercontent.com/52172169/202908215-846b90dd-3047-4892-8f2b-674f77e670f8.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
