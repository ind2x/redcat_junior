# 간단한 파일 시스템을 구현하자

<br>

이번 장에서는 클러스터 링크를 기반으로 한 파일 시스템 구현, 파일 시스템의 기본이 되는 저수준 함수 구현, 고수준 함수 기반 다지기

<br>

파일 시스템은 저장매체를 관리하는 일종의 규약으로 대표적으로 MS의 FAT 12/16/32가 있다.

따라서 규약이기 때문에 윈도우에서 저장한 파일을 리눅스에서도 읽을 수 있는 것이다. (동일한 규약이기 때문에)

<br>

FAT는 섹터 단위로 데이터를 저장하는 것이 아니라, 여러 섹터 단위(클러스터 단위)로 저장한다.

클러스터는 링크 형식으로 다음 클러스터와 연결된다.

필요한 정보로는 데이터의 크기에 따른 클러스터 개수라든가, 다음 클러스터의 위치가 필요하다.

즉, 클러스터 링크 방식은 필요한 메타 데이터가 적으며 구현이 쉽다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## MINT 파일 시스템 설계

<br>

우선 우리가 만들 MINT 파일 시스템은 매우 간단한 클러스터 링크 방식의 파일 시스템이다.

아래는 MINT 파일 시스템 특징이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204119754-2c06f563-08f2-4a62-996a-55831c181f74.png)

<br>

우리의 파일 시스템은 아래와 같고, 특징은 다음과 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204119946-bbabd85d-e54c-42bd-8995-2b035bc55664.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/204119949-82c351d7-9a04-4b64-9ee8-3c5ff1e4994c.png)

<br>

가장 중요한 영역은 클러스터 링크 테이블 영역으로, 클러스터의 정보를 저장하고 관리하는데 해당 클러스터의 할당 여부를 저장하고, 다음에 연결된 클러스터의 인덱스를 저장한다.

해당 영역은 데이터를 ```추가 / 삭제 / 읽기``` 를 할 때 사용한다.

<br><br>

### MBR 영역
---

<br>

먼저 **MBR**영역을 살펴본다.

MBR 영역에는 ```부트 코드, 파일 시스템 정보, 파티션 정보```가 들어있다.

파티션이란 하드 디스크를 **논리적**으로 영역을 분할한 것이며, MBR 영역의 뒤쪽의 파티션 테이블 영역에 정보를 기록하여 생성한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204120391-567bfa54-18e7-4802-ae56-aa5f3ba5b3dd.png)

<br>

파티션 테이블 영은 MBR 시작 어드레스로부터 446바이트 떨어진 곳에 위치하며, 16바이트의 크기로 4개의 파티션이 있다. 

부팅 가능 여부, 파티션의 시작과 끝, 파티션 종류, 총 섹터 수가 저장된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204120445-ac3959ef-f299-4dc8-a4e9-ccf0a5423500.png)

<br>

파티션을 생성할 때, 곂치는 부분이 있어선 안된다.

파티션 생성은 선택 사항으로, 하드 디스크 전체를 하나의 파일 시스템으로 사용하고자 한다면 파티션 테이블을 모두 0으로 초기화 해주면 된다.

MINT 파일 시스템은 파티션을 사용하지 않는다.

<br><br>

### 클러스터 링크 테이블 영역과 데이터 영역
---

<br>

클러스터 링크 테이블 영역에는 **각 클러스터의 사용 여부, 다음에 연결된 클러스터의 인덱스를 저장**한다.

링크 정보는 클러스터 수만큼 존재하며, 링크 정보의 인덱스는 데이터 영역의 클러스터의 인덱스와 같다.

링크 정보는 4바이트 크기로, 필요한 링크 테이블 크기는 ```4 * 클러스터 개수```가 된다.

하지만 하드 디스크는 섹터 단위로 처리하기 때문에 계산된 값을 섹터 단위로 올림한 값이 크기가 된다.

<br>

데이터 영역은 위의 메타 데이터를 제외한 나머지 영역으로 클러스터 단위로 정렬되어있다.

MINT 파일 시스템은 섹터 8개, 4KB를 묶어서 클러스터로 사용하므로 4KB 미만의 공간은 버려서 데이터 영역을 클러스터 단위로 정렬한다.

파일 또한 클러스터 단위로 저장하고 처리한다.

<br>

그래서 파일 시스템의 핵심은 클러스터를 찾는 것이다.

파일을 삭제하고 생성을 반복하면 클러스터가 흩어질 수 있기 때문에 다음 클러스터를 찾는 것이 중요하다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204121569-6763f09e-2473-4c3a-8b1d-0cef9462481b.png)

<br>

위의 예를 보면 클러스터가 연속되지 않고 흩어질 수 있음을 보여주며, 클러스터 링크 테이블에는 다음 클러스터의 정보가 저장되어 있고 마지막 클러스터(파일의 끝)의 클러스터 링크 테이블 인덱스에는 끝을 알려주는 값이 들어있어서 이를 통해 끝임을 알 수 있다.

<br>

파일의 시작 클러스터에 대한 내용은 디렉터리가 가지고 있으며, 디렉터리는 파일의 이름, 파일의 시작 클러스터 정보, 파일의 크기 등의 정보를 담고 있다.

MINT 파일 시스템의 0번 클러스터(최상위 클러스터)는 루트 디렉터리로 사용한다.

<br><br>

### 루트 디렉터리와 파일
---

<br>

MINT 파일 시스템은 루트 디렉터리만 사용하고 서브 디렉터리를 지원하지 않는, 수평적 관계를 갖는다.

왜냐하면 MINT 파일 시스템은 간단한 파일 시스템이기 때문이며, 서브 디렉터리를 지원한다면 트리 형태의 디렉터리 구조가 되기 때문에 파일 경로 처리에 여러 가지를 고려해야 한다.

<br>

루트 디렉터리 자료구조는 파일의 정보를 저장하는 필드로 가득 차 있으며 총 32바이트이며, 이를 **디렉터리 엔트리**라고 한다.

클러스터 크기가 4KB이므로 엔트리를 최대 128개 생성할 수 있다고 한다. (즉 파일 128개?)

<br>

파일을 루트 디렉터리에 추가하려면 빈 디렉터리 엔트리를 찾아야 하며 이는 시작 클러스터 인덱스가 0인지를 통해 확인한다.

클러스터 인덱스 0은 루트 디렉터리이므로 파일은 시작 클러스터 인덱스가 0이 될 수 없으므로 이를 이용해 판단한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/204122100-17e1039d-5992-4428-b39a-cdd5205671df.png)

<br><br>

### 파일 추가/삭제 알고리즘
---

<br>

![image](https://user-images.githubusercontent.com/52172169/204122417-866cfe83-eef9-4806-8035-a326ee04aa99.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/204122621-4448242e-d679-4580-a088-165f1d54f6fa.png)

<br>

물론 위의 알고리즘은 파일의 클러스터가 한 개인 경우를 뜻하며 여러 개의 경우 클러스터를 따라 설정하거나 초기화하는 과정이 필요하다.

<br><br>

### MINT 파일 시스템 자료구조 설계
---

<br>



<br><br>
<hr style="border: 2px solid;">
<br><br>
