# GDT, IDT 테이블, TSS 세그먼트를 추가해 인터럽트에 대비하자

<br>

인터럽트와 예외처리의 기본이 되는 **TSS 세그먼트와 IDT 테이블을 생성하는 방법**에 대해 알아보고 임시 핸들러를 통해 확인해 볼 것이다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외

<br>

인터럽트(외부 디바이스가 발생시킴)나 예외(프로세서가 발생시킴)가 발생하면 벡터 테이블로 가서 처리함수를 통해 처리를 한다.

보호모드와 IA-32e 모드에서는 이것을 IDT 벡터 테이블이 담당한다.

<br>

**IDTR 레지스터를 이용**해서 **프로세서에 IDT 테이블의 정보를 설정**할 수 있다.

IDT 테이블에는 **IDT 게이트 디스크립터**가 있으며 **최대 256개의 엔트리(디스크립터)** 를 포함할 수 있고,  **IA-32e 모드에서는 16바이트**이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018371-45233159-2b9c-40a2-9450-35bc3ee7f84c.png)

<br>

아래는 디스크립터의 구조와 필드의 의미이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018445-2df2be60-d5c4-4dd7-b8a3-b56a0a573c3a.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/198018479-82b0cc9e-583a-4e27-9dcc-f10031a2d591.png)

<br>

MINT64 OS에서는 인터럽트 도중 다른 인터럽트를 허용하지 않으므로 IDT 게이트의 타입을 **인터럽트 타입으로 설정**한다. 

<br>

x86 프로세서는 **IDT 테이블에서 상위 32개의 디스크립터를 예외처리에 사용**하는데, 상위 32개를 예약을 하는데 **그 중 20개는 실제로 사용**하며 **나머지 12개는 미리 예약**해둔 것이다.

나머지 224개는 인터럽트와 시스템 콜 용도로 사용한다.

<br>

프로세서가 사용하는 20개의 예외는 크게 Faults, Traps, Aborts로 구분할 수 있다.

<br>

+ Faults
  + 해당 코드만 수정하면 정상적으로 동작이 되는 예외
  + 복귀 주소는 Faults가 발생한 코드로, 핸들러의 실행이 완료되면 해당 코드부터 시작

<br>

+ Traps
  + Trap을 유발하는 명령어를 실행했을 때 발생하는데, 거의 디버깅 명령어
  + 복귀 주소는 Traps 유발 코드의 다음 코드

<br>

+ Aborts
  + 심각한 문제 발생으로 문제 발생 주소를 알 수 없고 더 이상 코드를 수행할 수 없는 상태
  + OS가 오동작하거나 리부트 될 수 있다.

<br>

이번엔 인터럽트를 살펴보면 인터럽트는 32번부터 총 15개로 47번까지 사용하고 있다.

각각에는 IRQ 번호가 부여되어 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198022813-0e50b551-e2d9-4311-88d8-d19ce89dc1f7.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외, 스택과 태스크 상태 세그먼트

<br>

스택과 스택 스위칭은 인터럽트와 예외를 처리한 후 복귀할 때 중요한 부분으로, **기존에 사용하던 스택에서 인터럽트와 예외 처리용 스택으로 넘어가서 처리**하게 되는데, 이 때 **기존 스택의 주소를 저장하고 넘어간 뒤, 처리가 끝난 후 해당 주소로 다시 복귀**한다.

<br><br>

### 스택 스위칭과 IST
---

<br>

스택 스위칭을 하는 이유는 ```1. 핸들러가 코드를 처리하는 도중 스택의 부족으로 오류가 발생하지 않게 하기 위함```과 ```2. 권한이 높은 함수가 낮은 권한의 함수에 간섭하는 것을 최소화```하기 위함이다.

보호모드에서는 IST가 없는데, IA-32e 모드에서는 IST를 도입하였고 이유는 **IST가 없다면 최상위 권한의 커널 코드를 처리하다가 인터럽트나 예외가 발생하면 스택 스위칭이 되지 않는다.**

왜냐하면 **스택 스위칭은 권한이 변경이 되어야만 발생**하기 때문이다.

<br>

IST는 최대 7개의 스택을 지정할 수 있고, 반드시 스택 스위칭이 발생한다.

MINT64 OS에서는 커널 스택 영역 이후 7MB ~ 8MB 영역을 IST 공간으로 할당하였다.

설정하는 방법은 IST 게이트 디스크립터의 IST 필드를 0이 아닌 1 ~ 7 사이의 값으로 설정해주면 된다.

IST를 통해 인터럽트/예외를 처리 및 복귀하는 방식은 스택에 기존의 스택 정보를 저장하고 복귀 시 저장한 정보를 토대로 복귀한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198025734-a8e6814a-4705-48ce-b902-09336d1345ae.png)

<br>

IST와 관련된 정보는 TSS 세그먼트(Task Status Segment)를 이용하여 저장한다.

TSS 레지스터는 레지스터의 정보를 저장하는 **세그먼트**로, 보호모드에서는 유용하였으나 IA-32e 모드에서는 쓸모가 없었지만 총 7개의 IST 정보를 저장하는데 활용하게 되었다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198028080-dfeefe15-79be-4cf6-b659-17dadf586efd.png)

<br>

세그먼트이기 때문에 사용하려면 프로세서에 세그먼트의 주소를 알려줘야 한다.

바로 **TSS 디스크립터와 LTR 명령어**를 이용하면 된다.

TSS 디스크립터도 마찬가지로 GDT 테이블에 있는데, 차이점은 다른 디스크립터(8바이트)와 달리 16바이트이다.

하위 8바이트는 동일하며 상위 8바이트는 64비트 주소를 나타내는데 활용한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198028663-d5997114-daa4-43b8-91b1-55fa98f2ef04.png)

<br>

하위 8바이트에 새로운 필드인 B 필드가 보이는데, 이 필드는 보호모드에서 유용했던 필드로 IA-32e 모드에서 동작하는 MINT64 OS에서는 필요없으므로 0으로 설정한다.

이제 남은 건 **프로세서에 어떤 TSS가 수행중인가?** 를 알려주는 것인데, 이것은 LTR 명령어로 나타낸다.

LTR 명령어를 수행하는 순간 프로세서에 모든 TSS 세그먼트의 정보가 로드되므로 **가장 마지막에 수행**한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## GDT 테이블 교환과 TSS 세그먼트 디스크립터 추가

<br>

이번 장에서 기존에 사용하던 GDT를 갈아엎고 TSS 세그먼트 디스크립터를 추가해 줄 것이다.

그럼 왜 교환해야 하는가?

TSS 세그먼트 디스크립터는 104바이트로, 기존에 작성한 GDT 테이블은 보호 모드 커널 엔트리 포인트 영역에 있는데, 커널 엔트리 포인트 영역(512바이트)에 비해 TSS 디스크립터 크기가 너무 크다.

또 다른 이유로 인해서 그냥 별도의 1MB 이상의 영역에 GDT 테이블을 생성해 줄 것이고, C 코드로 작성해 줄 것이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198039385-3fda8c7e-fd8d-48c7-b394-87a029a908bd.png)

<br>

GDT 테이블 생성 코드는 책을 참고한다.

0x142000을 GDTR의 시작 주소로 설정한 이유는 1MB부터 +264KB에 페이지 테이블로 사용할 것이기 때문이다.

<br>

이제 TSS 세그먼트를 초기화해주는데, TSS 세그먼트는 스택에 대한 필드와 I/O 맵에 대한 필드로 구성되어 있다.

I/O 맵은 사용하지 않을 것이며, IST를 이용할 것이므로 이에 맞춰 초기화해준다.

I/O 비활성화는 **I/O 맵 기준 주소를 TSS 세그먼트 디스크립터에서 설정한 Limit 필드 값보다 크게 설정**해주면 된다.(0xFFFF)

IST는 **IST 필드를 1 ~ 7 사이의 값으로 설정**하고, **TSS 세그먼트의 해당 IST 영역에 핸들러가 사용할 스택 주소를 설정**한다.

주의점으로 반드시 16바이트로 정렬된 위치에서 시작해야 한다.

<br>

이제 GDT 테이블을 교체하는 방법으로 마찬가지로 LGDT 명령어를 통해 갱신시켜준다.

그 다음 IDT 테이블을 생성 및 초기화해준다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## IDT 테이블 생성, 인터럽트, 예외 핸들러 등록

<br>

IDT 테이블을 생성하고 초기화해준다.

IDTR 자료구조의 시작 주소는 TSS 세그먼트를 설정해준 영역 다음인 0x1420A0이다.

IDT 테이블 초기화 코드는 책을 참고하고, 초기화 후에는 이제 IDT 테이블을 프로세서에 로드해야 한다.

<br>

IDT 테이블을 프로세서에 로드하는 방법은 GDT 테이블을 로드하는 방법과 비슷하다.

IDTR 레지스터가 있으며, LIDT 명령어를 이용한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198047929-54666d30-533d-4d05-99e9-8179856e89ce.png)

<br>

위의 어셈블리 코드에 있는 함수를 C코드로 작성하여 프로세서에 로드해주면 된다.

이제 남은건 전체 코드를 짜주기만 하면 된다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## IDT, TSS 통합과 빌드

<br>

위에서 배운 내용들을, 코드들을 작성하여 빌드해줄 것이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198208268-4b7608a9-3549-4c45-b0fd-e74e810a1356.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
