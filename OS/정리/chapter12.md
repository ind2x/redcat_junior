# GDT, IDT 테이블, TSS 세그먼트를 추가해 인터럽트에 대비하자

<br>

인터럽트와 예외처리의 기본이 되는 **TSS 세그먼트와 IDT 테이블을 생성하는 방법**에 대해 알아보고 임시 핸들러를 통해 확인해 볼 것이다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외

<br>

인터럽트(외부 디바이스가 발생시킴)나 예외(프로세서가 발생시킴)가 발생하면 벡터 테이블로 가서 처리함수를 통해 처리를 한다.

보호모드와 IA-32e 모드에서는 이것을 IDT 벡터 테이블이 담당한다.

<br>

**IDTR 레지스터를 이용**해서 **프로세서에 IDT 테이블의 정보를 설정**할 수 있다.

IDT 테이블에는 **IDT 게이트 디스크립터**가 있으며 **최대 256개의 엔트리(디스크립터)**를 포함할 수 있고,  **IA-32e 모드에서는 16바이트**이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018371-45233159-2b9c-40a2-9450-35bc3ee7f84c.png)

<br>

아래는 디스크립터의 구조와 필드의 의미이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018445-2df2be60-d5c4-4dd7-b8a3-b56a0a573c3a.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/198018479-82b0cc9e-583a-4e27-9dcc-f10031a2d591.png)

<br>

MINT64 OS에서는 인터럽트 도중 다른 인터럽트를 허용하지 않으므로 IDT 게이트의 타입을 **인터럽트 타입으로 설정**한다. 

<br>

x86 프로세서는 **IDT 테이블에서 상위 32개의 디스크립터를 예외처리에 사용**하는데, 상위 32개를 예약을 하는데 **그 중 20개는 실제로 사용**하며 **나머지 12개는 미리 예약**해둔 것이다.

나머지 224개는 인터럽트와 시스템 콜 용도로 사용한다.

<br>

프로세서가 사용하는 20개의 예외는 크게 Faults, Traps, Aborts로 구분할 수 있다.

<br>

+ Faults
  + 해당 코드만 수정하면 정상적으로 동작이 되는 예외
  + 복귀 주소는 Faults가 발생한 코드로, 핸들러의 실행이 완료되면 해당 코드부터 시작

<br>

+ Traps
  + Trap을 유발하는 명령어를 실행했을 때 발생하는데, 거의 디버깅 명령어
  + 복귀 주소는 Traps 유발 코드의 다음 코드

<br>

+ Aborts
  + 심각한 문제 발생으로 문제 발생 주소를 알 수 없고 더 이상 코드를 수행할 수 없는 상태
  + OS가 오동작하거나 리부트 될 수 있다.

<br>

이번엔 인터럽트를 살펴보면 인터럽트는 32번부터 총 15개로 47번까지 사용하고 있다.

각각에는 IRQ 번호가 부여되어 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198022813-0e50b551-e2d9-4311-88d8-d19ce89dc1f7.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외, 스택과 태스크 상태 세그먼트

<br>

스택과 스택 스위칭은 인터럽트와 예외를 처리한 후 복귀할 때 중요한 부분으로, **기존에 사용하던 스택에서 인터럽트와 예외 처리용 스택으로 넘어가서 처리**하게 되는데, 이 때 **기존 스택의 주소를 저장하고 넘어간 뒤, 처리가 끝난 후 해당 주소로 다시 복귀**한다.

<br><br>

### 스택 스위칭과 IST
---

<br>



<br><br>

<br><br>
<hr style="border: 2px solid;">
<br><br>
