# GDT, IDT 테이블, TSS 세그먼트를 추가해 인터럽트에 대비하자

<br>

인터럽트와 예외처리의 기본이 되는 **TSS 세그먼트와 IDT 테이블을 생성하는 방법**에 대해 알아보고 임시 핸들러를 통해 확인해 볼 것이다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외

<br>

인터럽트(외부 디바이스가 발생시킴)나 예외(프로세서가 발생시킴)가 발생하면 벡터 테이블로 가서 처리함수를 통해 처리를 한다.

보호모드와 IA-32e 모드에서는 이것을 IDT 벡터 테이블이 담당한다.

<br>

**IDTR 레지스터를 이용**해서 **프로세서에 IDT 테이블의 정보를 설정**할 수 있다.

IDT 테이블에는 **IDT 게이트 디스크립터**가 있으며 **최대 256개의 엔트리(디스크립터)**를 포함할 수 있고,  **IA-32e 모드에서는 16바이트**이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018371-45233159-2b9c-40a2-9450-35bc3ee7f84c.png)

<br>

아래는 디스크립터의 구조와 필드의 의미이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198018445-2df2be60-d5c4-4dd7-b8a3-b56a0a573c3a.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/198018479-82b0cc9e-583a-4e27-9dcc-f10031a2d591.png)

<br>

MINT64 OS에서는 인터럽트 도중 다른 인터럽트를 허용하지 않으므로 IDT 게이트의 타입을 **인터럽트 타입으로 설정**한다. 

<br>

x86 프로세서는 **IDT 테이블에서 상위 32개의 디스크립터를 예외처리에 사용**하는데, 상위 32개를 예약을 하는데 **그 중 20개는 실제로 사용**하며 **나머지 12개는 미리 예약**해둔 것이다.

나머지 224개는 인터럽트와 시스템 콜 용도로 사용한다.

<br>

프로세서가 사용하는 20개의 예외는 크게 Faults, Traps, Aborts로 구분할 수 있다.

<br>

+ Faults
  + 해당 코드만 수정하면 정상적으로 동작이 되는 예외
  + 복귀 주소는 Faults가 발생한 코드로, 핸들러의 실행이 완료되면 해당 코드부터 시작

<br>

+ Traps
  + Trap을 유발하는 명령어를 실행했을 때 발생하는데, 거의 디버깅 명령어
  + 복귀 주소는 Traps 유발 코드의 다음 코드

<br>

+ Aborts
  + 심각한 문제 발생으로 문제 발생 주소를 알 수 없고 더 이상 코드를 수행할 수 없는 상태
  + OS가 오동작하거나 리부트 될 수 있다.

<br>

이번엔 인터럽트를 살펴보면 인터럽트는 32번부터 총 15개로 47번까지 사용하고 있다.

각각에는 IRQ 번호가 부여되어 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198022813-0e50b551-e2d9-4311-88d8-d19ce89dc1f7.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트와 예외, 스택과 태스크 상태 세그먼트

<br>

스택과 스택 스위칭은 인터럽트와 예외를 처리한 후 복귀할 때 중요한 부분으로, **기존에 사용하던 스택에서 인터럽트와 예외 처리용 스택으로 넘어가서 처리**하게 되는데, 이 때 **기존 스택의 주소를 저장하고 넘어간 뒤, 처리가 끝난 후 해당 주소로 다시 복귀**한다.

<br><br>

### 스택 스위칭과 IST
---

<br>

스택 스위칭을 하는 이유는 ```1. 핸들러가 코드를 처리하는 도중 스택의 부족으로 오류가 발생하지 않게 하기 위함```과 ```2. 권한이 높은 함수가 낮은 권한의 함수에 간섭하는 것을 최소화```하기 위함이다.

보호모드에서는 IST가 없는데, IA-32e 모드에서는 IST를 도입하였고 이유는 **IST가 없다면 최상위 권한의 커널 코드를 처리하다가 인터럽트나 예외가 발생하면 스택 스위칭이 되지 않는다.**

왜냐하면 **스택 스위칭은 권한이 변경이 되어야만 발생**하기 때문이다.

<br>

IST는 최대 7개의 스택을 지정할 수 있고, 반드시 스택 스위칭이 발생한다.

MINT64 OS에서는 커널 스택 영역 이후 7MB ~ 8MB 영역을 IST 공간으로 할당하였다.

설정하는 방법은 IST 게이트 디스크립터의 IST 필드를 0이 아닌 1 ~ 7 사이의 값으로 설정해주면 된다.

IST를 통해 인터럽트/예외를 처리 및 복귀하는 방식은 스택에 기존의 스택 정보를 저장하고 복귀 시 저장한 정보를 토대로 복귀한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198025734-a8e6814a-4705-48ce-b902-09336d1345ae.png)

<br>

IST와 관련된 정보는 


<br><br>

<br><br>
<hr style="border: 2px solid;">
<br><br>
