# 코어 개수와 시스템 구성 정보를 추출하자

<br>

멀티프로세서, 멀티코어 프로세서 환경과 싱글코어 프로세서 환경의 차이점을 살펴본다.

부팅 과정에서 호환성을 유지하기 위해 인터럽트 전달 경로를 어떻게 설정하는지 알아본다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 멀티코어 프로세서와 BIOS

<br>

싱글 코어에서는 시분할 멀티태스킹을 통해 태스크를 병렬처리를 하는 것처럼 보이게 하였다.

하지만 멀티코어에서는 진정한 병렬처리를 하기 때문에 더 좋은 성능을 낸다.

사용자 입장에서는 당연히 멀티코어 프로세서가 더 좋겠지만, OS 제작자 입장에서는 복잡한 문제이다.

<br>

첫 째로, 커널 자료구조를 다시 정의해야하는데, 코어 별로 관리를 해주는 자료구조와 코어 간에 자료를 공유하는 자료구조를 설계해야 한다.

두 번째로, 부하를 분산시켜야 한다. 하나의 코어에만 태스크가 몰려있으면 싱글 코어와 다를 바가 없기 때문에 코어를 모니터링하여 적절하게 태스크를 분산해야 한다.

이 외에도 다양한 문제점들이 있지만, 30장에서 차근차근 알아간다고 한다.

<br>

우리는 BIOS를 이용하여 몇 가지 작업을 줄일 수 있다고 한다.

BIOS는 부트 로더를 디스크에서 로딩하여 실행하는 역할이었는데, BIOS는 그 전에 POST 과정을 한다.

POST 과정에서는 프로세서 초기화 과정이 있는데, 이 부분이 바로 29장의 핵심이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/205571235-71a7f631-c678-4987-a0cc-6c5b817e0dcb.png)

<br>

POST 과정에서 프로세서를 초기화 하고 BIOS는 부팅 과정을 진행할 코어를 제외한 나머지 코어는 대기 시켜둔다.

이 부팅 과정을 실행하는 코어를 BSP(BootStrap Processor)라고 하며, 나머지 대기하는 코어들을 AP(Application Processor)라고 한다.

즉, **BIOS는 프로세서가 몇 개인지 알고 있다는 뜻**이다.

<br>

BIOS는 리얼모드로 설정하는 과정에서 인터럽트가 BSP로만 가게끔 **인터럽트 전달 경로를 설정**한다.

우리는 인터럽트가 PIC 컨트롤러를 통해 전달된다는 것을 알고 있는데, 이는 **싱글코어 환경에서만 사용 가능**하다.

즉, **멀티코어 환경에서는 새로운 장치가 필요**하며, 이를 **APIC, I/O APIC**가 담당한다.

APIC, I/O APIC는 여러 코어로 인터럽트를 전달할 수 있게끔 설계 되었으며, **BIOS는 APIC, I/O APIC, 기타 레지스터를 설정하여 PIC 컨트롤러를 통해 인터럽트를 전달되도록 한다.**

그리고 인터럽트가 BSP로만 전달되게끔 하여 마치 **싱글코어 프로세서 환경인 것처럼** 만든다.

또한 BIOS는 나머지 AP 코어들을 깨워주지 않는다. 즉, 우리가 사용하려면 직접 설정을 해줘야 한다는 뜻이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/205576431-f452dd87-0606-4702-878a-b07a94cf28a6.png)

<br>

구조를 살펴보면 다음과 같다.

프로세서 안에 코어들이 있고, 코어 안에는 CPU와 로컬 APIC가 들어있으며, 이 로컬 APIC는 다른 코어의 로컬 APIC와 연결되며, I/O APIC와 연결된다.

<br>

+ 로컬 APIC(Advanced Programmable Interrupt Controller)
  + PIC 컨트롤러나 I/O APIC에서 전달하는 인터럽트를 처리
    + 인터럽트 라인을 연결할 수 있는 LINT0, LINT1 핀을 통해 인터럽트를 직접 처리할 수 있음 
    + APIC 버스, ICC 버스(Interrupt Controller Communication Bus)를 통해 I/O APIC로부터 인터럽트를 전달받아 처리할 수 있음
  
  <br>
  
  + 기존 방식과의 차이점은 태스크 우선순위 레지스터가 있어서 특정 벡터 범위만 선택하여 처리하는 것이 가능
    + 기존에는 프로세서로 모든 인터럽트가 전달되었으나 로컬 APIC의 우선순위 레지스터를 사용하면 코어별로 인터럽트 벡터를 나누어 처리가능
  
  <br>
  
  + 외부 인터럽트 처리 기능외에 코어나 프로세서 간의 인터럽트를 생성하고 처리하는 IPI(Inter-Processor Interrupt) 메시지 처리 기능도 있음
    + IPI는 프로세서나 코어가 임시로 생성할 수 있는 인터럽트로 다른 프로세서나 코어 활성화 및 특정 인터럽트 벡터 실행 시 사용됨
    + 프로세서나 코어가 동시에 특정 작업을 수행할 필요가 있을 때도 사용됨   

<br>

+ I/O APIC와 PIC 컨트롤러
  + PIC 컨트롤러는 하나의 프로세서로만 인터럽트를 전달
  
  <br>
  
  + I/O APIC는 멀티프로세서나 멀티코어 프로세서 환경에서 사용되며, PIC 컨트롤러처럼 외부의 인터럽트를 취합하여 로컬 APIC로 전달하는 역할
    + I/O APIC는 ICC버스나 APIC 버스를 통해 로컬 APIC와 연결
    + 설정 값에 따라 모든 로컬 APIC나 특정 로컬 APIC로 인터럽트 전달
    + 24개의 인터럽트 라인을 동시에 처리 가능
    + 외부 디바이스의 인터럽트 라인을 직접 연결하거나 PIC 컨트롤러를 거쳐 연결하는 것이 가능

<br>

하지만 부팅 과정에서는 결국 싱글 프로세서 환경인 것처럼 동작해야 한다.

이런 환경에서 인터럽트 모드는 3가지가 있는데, ```PIC 모드, 로컬 APIC를 통한 가상 연결 모드, I/O APIC를 통한 가상 연결 모드```가 있다.

이 세가지 모드는 직접 설정할 필요는 없고, 어떤 경로로 연결되는지 정도만 보면 되므로 p.1275에서 직접 읽으면서 복습.

<br>

PIC 모드는 **BSP에 PIC 컨트롤러의 인터럽트 라인을 직접 연결하는 방식**이다.

가상 연결 모드는 **PIC 컨트롤러의 인터럽트 라인**을 **로컬 APIC나 I/O APIC**에 연결하는 방식이다.

<br>

지금까지 BIOS가 멀티 환경에서 싱글 코어 환경처럼 구성하는지에 대해 배웠고, BIOS가 구성하는 호환 모드의 종를 아는 것도 중요하지만 더 중요한 점은 현재 호환 모드가 어떤 것인지 아는 것이다.
 
이 정보는 당연히 BIOS에서 얻을 수 있으며, 여러 정보를 BIOS의 데이터 영역에 저장하는데 이 영역을 **MP 설정 테이블**이라고 한다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>

## MP 설정 테이블 구조

<br>

MP 설정 테이블은 **프로세서와 시스템 버스, I/O APIC에 대한 정보가 저장된 테이블**이다.

이번 절에서 MP 설정 테이블을 찾는 방법과 분석하는 방법을 배운다. p.1279부터 정독

<br>



<br><br>
<hr style="border: 2px solid;">
<br><br>
