# 콘솔 셸을 만들자

<br>

**셸을 구현하는데 필요한 콘솔 라이브러리를 구현**하고, 콘솔 라이브러리를 구성하는 printf, sprintf 함수를 구현하는데 필요한 가변 인자 처리 방법을 살펴본다.

구현한 콘솔 라이브러리를 바탕으로 셸을 구현한다.

<br>

셸은 크게 3가지로 구성되는데 ```1) 키보드에서 키를 입력받아 커맨드 버퍼를 관리하고 커맨드 실행```, ```2) 텍스트 화면 관리로, 커서의 위치를 제어하고 화면에 데이터를 출력하는 기능```, ```3) 프로그램 실행```이다.

셸의 목적은 프로그램을 실행하는 것이며 셸을 통하지 않고 독립적으로 실행 가능하다.

셸은 거의 입출력 라이브러리가 더 큰 비중을 차지하므로 sprintf를 살펴본다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>

## sprintf와 가변 인자 처리

<br>

C언어는 가변인자 처리를 위해 va_list 데이터 타입과 va_start, va_arg, va_end 라는 매크로를 사용한다.

이는 stdarg.h에 선언되어 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/199242529-08404098-dcc4-42c4-9486-6f484772780a.png)

<br>

확인해보면 가변 인재 매크로는 라이브러리를 사용하지 않아서 mint64 os에서 사용 가능하다고 한다.

<br>

이제 sprintf 함수를 보고 vsprintf 함수를 이용해 printf 함수를 구현해 줄 것이다.

sprintf 함수는 결과를 문자열 버퍼에 출력하고, printf 함수는 결과를 화면에 출력한다.

vsprintf 함수는 sprintf 함수의 실질적인 역할을 해주는 함수로 가변 인자 대신에 va_list 타입의 가변 인자 리스트를 받아서 처리한다.

<br>

나머지 코드 부분은 책으로 보면 될 것 같다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 콘솔 입출력 처리

<br>

콘솔은 텍스트 방식이나 명령줄 방식으로 작업을 수행하는 **입출력 장치**로, 입력 장치는 키보드이고 출력 장치는 모니터가 된다.

따라서 콘솔 입출력을 담당할 **콘솔 입출력 라이브러리를 구현**할 것이다.

<br>

먼저 콘솔에서 사용할 배경색, 전경색, 비디오 메모리 등을 설정한 매크로를 정의하고 콘솔에 대한 정보를 저장할 자료구조를 생성한다.

이를 바탕으로 화면에 출력해줄 printf 함수를 정의한다.

printf 함수는 위에서 정의한 vsprintf 함수를 통해 정의를 하는데 아직 처리해줘야 하는 부분이 남아있는데 바로 **줄바꿈 문자와 탭 문자**다.

<br>

우리의 창은 가로 80에 세로 25로 최대 2000문자 표현 가능하다. 여기서는 창 안의 문자의 위치를 0부터 1999로 표현할 것이다. 

줄바꿈 문자는 80의 배수로 이동시켜주면 되고 탭 문자는 8의 배수로 커서를 이동시켜주면 되는데, 창의 크기는 제한되어 있으므로 항상 유효하지 않다.

그래서 **스크롤**를 통해 해결해줘야 한다. 물론 실제 스크롤이 아니고 **스크롤 효과**를 내주는 것이다.

<br>

스크롤 효과는 **첫째 줄을 제외한 나머지 줄을 위로 한 줄씩 옮겨주는 것으로, 위로 한 줄씩 복사해주는 것**이다.

그리고 **마지막 라인을 공백으로 초기화**해주어서 새로운 라인이 아래에서 밀고 올라와 전체가 이동하는 듯한 효과를 낸 것이다.

<br>

이제 **커서의 위치를 업데이트 시켜줄 함수를 작성**해야 한다.

커서는 우리가 출력할 위치를 나타내주는데, 우리가 직접 ```_```를 출력해주는 것이 아니다.

**커서를 제어**하기 위해서는 모니터 출력을 담당하는 **VGA 컨트롤러를 이용**해야 한다.

우리는 커서 관련 기능만 볼 것이며, 커서 관련으로는 VGA 컨트롤러에는 ```CRTC Controller Address Register```와 ```CRTC Controller Data Register```가 담당하며 각각의 I/O 포트는 ```0x3D4, 0x3D5```를 사용한다.

여기서 **CRTC 컨트롤러 주소 레지스터는 컨트롤러의 내부 레지스터를 지정하는데, 커서의 위치를 제어하려면 0xE/0xF를 전달하여 상위/하위 커서 위치 레지스터를 먼저 지정**해야 한다.

그 다음에 **CRTC 컨트롤러 데이터 레지스터에 상위/하위 바이트로 나누어 커서 위치를 전달**하면 **커서를 해당 위치로 이동**시킨다.

<br>

기존에 키 처리 코드는 키 큐로부터 데이터를 읽어서 처리하였다.

그러나 셸을 키가 눌렸다는 정보와 아스키코드 값만 필요하므로 키가 눌리기를 기다려 ASCII코드를 반환하는 코드를 작성하였다.

이제 셸을 제작한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 셸 구현

<br>

프롬프트, 커맨드 버퍼, 사용자 입력을 제작 및 처리해야한다.

프롬프트 자체는 입력할 준비가 됬다는 신호이며 중요한 건 사용자 입력이다.

<br>

사용자 입력은 크게 세 가지로 구분한다.

첫째는 알파벳, 숫자 등 **셸 커맨드를 입력하는데 사용되는 그룹**이고 둘째는 **엔터, 백스페이스 등 입력된 커맨드를 조작하는 그룹**, 마지막은 **셸에서 사용되지 않는 그룹**으로 구분할 수 있다.

우리는 Shift, Caps Lock, Num Lock, Scroll Lock을 제외한 나머지는 입력 가능하게 처리하였다.

<br>

여기에 추가로 커맨드 버퍼를 추가하여 커맨드 버퍼에 입력 값을 담아주고 이를 이용해서 커맨드 실행 시 참조하도록 하였다.

<br>

이제 **커맨드 비교 및 실행 부분을 처리**해줘야 한다. 

커맨드 테이블을 정의해주는데 여기에는 커맨드 이름, 커맨드 도움말, 커맨드 실제 함수 주소를 넣어준다.

이전에 함수 포인터를 이용해 함수를 호출할 수 있도록 자료구조를 정의하였다.

이 자료구조와 커맨드 테이블을 통해 입력 값을 커맨드와 비교하여 해당 커맨드를 실행해준다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 콘솔 라이브러리 셸의 통합과 빌드

<br>



<br><br>
<hr style="border: 2px solid;">
<br><br>
