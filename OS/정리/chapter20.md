# 태스크와 인터럽트, 태스크와 태스크 사이의 동기화 문제 해결

<br>

19장 마지막에 테스트 과정에서 문제가 발생한 경우를 해결하기 위한 챕터이다.

테스트 도중 바람개비가 사라지거나 멈추는 현상이 발생할 수 있는데, 이의 원인은 바로 같은 ```같은 자료구조의 사용```으로 태스크와 인터럽트가 같은 준비 리스트, 대기 리스트를 사용하기 때문에 발생하는 것이다.

즉, 같은 자원에 접근하는 코드가 여러 곳에서 동시에 실행되어 발생하는 것이며 이를 막기 위해서는 여러 태스크나 태스크와 인터럽트가 동시에 데이터를 사용할 때 이미 수행 중인 작업이 끝날 때 까지 **기다리는 과정**이 필요하며 이를 **동기화**라고 한다.

동기화를 위해 사용하는 자료구조를 **동기화 객체** 라고 하며 멀티쓰레드 프로그래밍인 뮤텍스나 세머포어가 이에 해당한다.

예를 들어, 버스를 통해 살펴보면 ```버스 = 공유 자원```, ```승객 = 태스크``` 으로 볼 수 있으며, 승객들이 규칙에 맞게 승/하차를 해야 정상적으로 버스가 운행이 될 수 있을 것이다.

여기서 ```규칙 = 동기화 객체```이며 ```사람이 규칙에 따라 승/하차 하는 과정 = 동기화 과정```이라고 볼 수 있다. 

<br>

이번 챕터에서 이 문제를 해결하고, 확장하여 동일한 문제가 있는 부분 또한 해결할 것이라고 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 태스크 생성 문제와 동기화 처리

<br>

태스크를 처리하는 도중 인터럽트가 발생하게 되면 태스크가 사라지는 현상이 발생하게 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/203236350-7b7ef5c7-7efa-44f6-9716-d3866afa3906.png)

<br>

자세한 내용은 p.727을 통해 복습하기.

이런 동기화 문제를 해결하기 위한 효율적인 방법을 이제 살펴볼 것이다.

<br>

멀티쓰레드 환경에서는 동기화를 처리하는 것은 매우 중요하다.

용어를 살펴보면 다음과 같다.

<br>

+ 같은 자원을 두고 경쟁하는 상태 == 경쟁 상태 (Race Condition)
 
+ 코드 중에서 반드시 한 개의 태스크만 수행되어야 하는 영역 == 임계 영역 (Critical Section)
 
+ 한 개의 태스크만 수행됨을 보장하는 용어 == 상호 배제 (Mutual Exclusion)

<br>

위의 용어를 사용하여 현재 문제를 정리해보면 다음과 같다.

<br>

+ 태스크와 인터럽트가 Race Condition 상태이다.

+ 임계 영역인 AddListToTail 함수를 호출하여 리스트 끝에 태스크를 추가한다.

+ 하지만 MINT64 OS에서는 이 임계영역이 상호 배제의 원칙이 수행되게끔 하는 코드가 없어서 문제가 발생한다.

<br>

**동기화를 처리하는 방법**은 **인터럽트를 제어하는 방법**과 **동기화 객체**인 Mutex, Semaphore를 **사용**하는 방법이 있다.

<br>

**인터럽트를 제어하는 방법**은 간단하게 **태스크와 인터럽트 간의 동기화를 위해서 인터럽트를 비활성화 한다는 것**이다.

단, 멀티코에 프로세서에서는 인터럽트를 비활성화 하는 것만으로는 동기화 처리를 할 수 없으며, 자세한 건 나중에 설명한다고 한다.

인터럽트 비활성화는 만병 통치약이긴 하나 비활성화 기간이 길수록 인터럽트 처리가 지연되므로 이를 고려해줘야 한다.

<br>

태스크 간의 동기화 문제는 **동기화 객체를 이용**하는 방법으로 처리하는데 대표적으로 Mutex, Semaphore 동기화 객체가 있다.

다음 절에서 구현하고 어떻게 적용하는지 살펴본다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트 제어와 동기화 객체를 통한 동기화

<br>

**인터럽트를 제어하는 방법**은 **임계 영역에 진입하기 전과 후에 인터럽트를 제어**하는 함수를 이용해 제어할 것이며 기존의 SetInterruptFlag 함수를 이용할 것이다.

**임계 영역에 진입하기 전에 인터럽트를 비활성화**하고 **임계영역의 끝에서 인터럽트를 비활성화 하기 전의 인터럽트 상태를 복원**해줄 것이다.

이제 구현한 함수를 필요한 곳에 적용할 것이다.

<br>

먼저 가장 시급한 곳은 스케줄러 함수이며 이를 해결한 뒤 키보드 함수도 같은 방식으로 동기화 처리를 해 줄 것이다.

스케줄러 함수에 모두 적용하면 동기화가 중복될 수 있으므로 적용 범위를 설정해야 한다.

**스케줄러 함수**를 살펴보면 **스케줄러 내부에서 호출되는 함수**들과 **외부에서 호출되는 함수**들로 **구분**할 수 있다.

관리하기 쉽게 외부에서 호출되는 함수들에 동기화 함수를 적용시켜주고 아래는 그 목록이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/203241997-efb5fc94-5faa-4df0-a360-85432af37e92.png)

<br>

**적용 부분은 임계함수에 진입하기 전과 후**이고 **임계 영역은 다른 태스크나 인터럽트 핸들러와 데이터를 공유하는 부분**이다.

키보드 함수 역시도 ConvertScanCodeAndPutQueue 함수와 GetKeyFromKeyQueue 함수에 동기화를 적용시켜야 한다.

키보드 함수는 기존에 이미 SetInterruptFlag 함수로 동기화 처리를 해줬어서 문제가 없었는데, 이 부분은 Lock, Unlock 함수로 대체해주면 된다.

<br>

이제 **태스크 간의 동기화 문제를 처리**해주는데, 뮤텍스와 세머포어의 공통점은 임계 영역에 진입하는 태스크의 수를 제한한다는 점이다.

단, 뮤텍스는 하나의 태스크만 허용하지만 세머포어는 여러 개를 허용해주는 등 차이점이 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/203245681-6a16605c-de9e-4db6-bd65-89a95761b24d.png)

<br>

위와 같은 차이점이 있으므로 구분해서 목적에 맞게 사용해야 한다.

우리는 뮤텍스를 사용할 것이며, 뮤텍스 자료구조를 정의해줘야 한다.

뮤텍스를 사용하는 목적은 **태스크의 개수를 제한**하는 것이며, 태스크 수는 임계 영역 진입 여부를 나타내는 플래그, 잠금 횟수를 나타내는 카운터, 태스크 ID를 이용해서 제한할 수 있다.

코드 등 자세한 내용은 p.740부터 복습해야겠다.

추가로 Printf 함수 또한 함수 자체가 커서 상대적으로 오래 걸리는데 이 과정에서 인터럽트가 발생될 수도 있으므로 동기화 처리를 해줘야 한다.

<br>

끝으로 동기화 객체에는 **교착 상태(DeadLock)** 문제가 발생한다고 한다.

데드락이란, 서로 다른 태스크가 두 개 이상의 동기화 객체를 흭득할 때 발생하는 문제로 어느 태스크도 더 이상 작업을 진행할 수 없을 때를 뜻한다.

자세한 설명은 p.751에서 복습.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 빌드

<br>

![image](https://user-images.githubusercontent.com/52172169/203263731-633c5991-4954-4e65-bcc8-e2bbf426872f.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
