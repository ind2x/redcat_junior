# 잠자는 코어를 깨우자

<br>

AP를 활성화 하기 위해서 **로컬 APIC에 대해 자세히 알아보고, 로컬 APIC의 ICR 레지스터를 통해 AP를 활성화** 한다.

그리고 **BSP와 AP 별로 자료구조를 생성하여 멀티코어를 처리할 수 있는 기능**을 만들어 줄 것이다.

<br>

29장에서는 싱글코어와 멀티코어 차이점, 로컬 APIC, I/O APIC 같은 시스템 정보를 저장하는 MP 설정 테이블 등을 배웠다.

30장에서는 이 정보를 이용해 AP를 활성화 하는 방법을 알아본다.

단, 활성화만 가능하고 아직 사용은 불가하며, IA-32e 모드로 진입하는 것까지만 해 줄 것이다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 로컬 APIC와 코어 활성화

<br>

로컬 APIC에서 코어를 활성화하는 메시지를 전달하기 때문에 이것부터 보고간다.

<br>

![image](https://user-images.githubusercontent.com/52172169/205827974-18dcfb98-b70d-4b83-98e0-7492b3c25a09.png)

<br>

로컬 APIC의 구조로, 내부와 외부 인터럽트는 특정 인터럽트 3개를 제외하면 벡터 테이블에 할당된 인터럽트 벡터와 프로세서의 우선순위를 비교하여 CPU로 전달한다.

로컬 APIC는 메모리 I/O 형식으로 되어 있어서 특정 범위의 주소 내에 있는 레지스터들의 주소에 값을 읽고 쓰는 방식으로 제어한다.

기준 주소는 프로세서나 코어가 리셋되면 0xFEE00000로 설정되며, 0xFEE00000 ~ 0xFEE003F0 범위 내에 수십 개의 레지스터들이 있다.

자세한 건 p.1337에서 확인

<br>

본론으로 가면 **AP를 활성화하려면 가장 먼저 로컬 APIC를 활성화**해야 한다.

로컬 APIC를 활성화하려면 두 가지 레지스터에 접근해야 한다.

하나는 IA32_APIC_BASE_MSR 레지스터이며, 다른 하나는 Spurious Interrupt Vector Register (의사 인터럽트 벡터 레지스터)이다.

IA32_APIC_BASE_MSR 레지스터는 MSR로 프로세서 모델 별로 정의된 **특수 목적 레지스터**로, **APIC 레지스터의 기준 주소, APIC 활성화 여부, BSP 여부를 담당**한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/205834328-988874ef-6874-41d3-b3b1-35cfdda8763b.png)

<br>

표를 보면 활성화 필드가 있다. 여기를 1로 설정해줘야 한다.

자세한 내용은 p.1339에서 확인.

<br>

로컬 APIC를 활성화 했다면 그 다음 의사 인터럽트 벡터 레지스터 차례다.

여기에는 **포커스 프로세서 검사 기능 사용 여부, 로컬 APIC 활성화 여부, 의사 벡터**를 저장한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/205839542-612329e6-7990-46d1-8685-fd4b54cc433b.png)

<br>

의사 인터럽트란 하드웨어와 소프트웨어 간의 시간 차로 발생하는 인터럽트이다.

자세한 내용은 p.1342에서 확인.

<br>



<br><br>
<hr style="border: 2px solid;">
<br><br>
