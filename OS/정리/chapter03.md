# 64비트 프로세스의 이모저모

## 운영모드
---

<br>

![image](https://user-images.githubusercontent.com/52172169/192705549-43e0824d-c4b9-40b0-b5c6-f1f7592563a0.png)

<br>

64비트 OS가 구현해야 할 필수 모드는 리얼모드, 보호모드, IA-32 모드 중 64비트 서브모드이다.

<br>

+ 리얼모드
  + 프로세스가 전원이 켜지거나 리셋되면 리얼모드로 진입
  + 리얼모드에서 BIOS의 기능을 사용 가능 -> 디바이스 드라이버를 제작할 필요가 없게 됨
    + BIOS는 디스크에서 읽기 및 쓰기 기능, 그래픽 모드 전환 기능 제공
  + 리얼모드는 디스크에 있는 OS 이미지를 메모리로 적재하는 작업을 수행
    + 이 과정은 어셈블리어로 이루어짐

<br>

+ 보호모드
  + 리얼모드에서 보호모드를 거쳐 IA-32e 모드로 전환됨
  + OS 필수 기능 (페이징 기법, 세그멘테이션 등)을 하드웨어적으로 지원해줌
  + 그만큼 복잡하고 다양한 레지스터와 알고리즘이 구현되어있음
  + 64비트 OS 관점에서는 중요치 않겠지만, IA-32e 모드를 이해하기 위해서 보호모드를 이해하는 것은 매우 중요

<br>

+ IA-32e (64비트 서브모드)
  + 32비트 서브모드와 64비트 서브모드가 있는데, 32비트 서브모드는 보호모드와 동일하다고 보면 됨
    + 즉, 보호모드의 주소 공간은 최대 2^32 제공
  + 보호모드에서 조금 더 크기가 확장되었다고 보면 되어, 보호모드와 큰 차이가 없으므로 보호모드만 제대로 이해를 한다면 큰 어려움이 없을 것임

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영모드 사이의 관계와 운영 모드의 전환

![image](https://user-images.githubusercontent.com/52172169/192710865-4b8e278a-62a0-43a8-9019-e9f443dff46d.png)

<br>

전원을 키면 리얼 모드로 진입을 하게 되는데, 리얼모드에는 공식적으로 갈 수 있는 모드는 보호모드 뿐이다.

비공식적으로 갈 수 있는 방법이 있다고 하긴 한다.

위의 사진에 표시된 내용은 모드를 전환할 때 필요한 조건들이라고 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영모드와 레지스터

![image](https://user-images.githubusercontent.com/52172169/192711857-3df715c4-e625-4de6-beeb-186914c258a2.png)

<br>

많이 필요한 레지스터는 범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터이다.

<br>

+ 범용 레지스터
  + 계산, 메모리 주소 지정, 임시 주소 공간 등 다양하게 사용됨 (범용)
  + 많을수록 처리가능한 양이 많아지므로 처리속도가 향상됨
  + 각각 정해진 기능이 있음

<br>

![image](https://user-images.githubusercontent.com/52172169/192721568-d5cf0ddd-70b3-4bf0-9593-a3efadd9d4aa.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/192721987-e26a4575-0145-4740-98e9-a4635674f81c.png)

<br><br>

+ 세그먼트 레지스터
  + 주된 역할은 어드레스 영역을 다양한 크기로 구분하는 역할이나, 모드마다 차이가 있음
  + 주소 공간을 목적에 따라 구분해주는 역할

<br>

![image](https://user-images.githubusercontent.com/52172169/192725127-741bbdac-52aa-4056-be87-def0f429117c.png)

<br>

+ 컨트롤 레지스터
  + 운영 모드를 변경하고, 현재 운영 모드의 특정 기능을 제어하는 역할
  + 그만큼 레지스터 자체가 복잡함
  + 리얼모드, 보호모드에서는 32비트, IA-32e에서는 64비트가 되지만 제약이 있음
    + CR0, CR4, CR8의 상위 32비트는 0으로 설정해야 함
    + CR2는 64비트 다 사용 가능
    + CR3는 비트 40부터 51까지 0으로 설정해야 함 

<br>

![image](https://user-images.githubusercontent.com/52172169/192727438-2f651654-fb14-4549-a3d1-960962249074.png)

<br>

운영모드와 레지스터는 OS 구현 시 반드시 알아야 하는 내용으로 최소한 레지스터 별로 무슨 역할을 하는지 정도는 알아둬야 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영모드와 메모리 관리 기법
### 리얼모드 메모리 관리 기법
---

<br>

**리얼모드**에서는 segmentation 기법만을 사용하며, segment 크기는 64KB로 고정이다.

**세그먼트 시작 주소**는 세그먼트 레지스터에 **직접 설정**을 해야 하고, 이 값은 **세그멘테이션에서 코드나 메모리 주소에 접근할 때 기준 주소로 사용**한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/192731378-4806c6d9-e7bf-475f-911e-a07419774318.png)

<br>

세그멘테이션을 거쳐 나온 주소가 곧 물리주소가 되며, 물리 주소를 계산하는 방식은 ```물리 주소 = 세그먼트 레지스터의 값*16 + 범용 레지스터 값```이다.

<br>

![image](https://user-images.githubusercontent.com/52172169/192731635-7062f94c-8fd8-4a24-9a9a-32aedb2cc0d8.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

### 보호모드 메모리 관리 기법
---

<br>

**보호모드**에서는 세그멘테이션 기법과 페이징 기법 모두 지원을 하며, 리얼 모드의 세그멘테이션보다 더 많은 기능이 있다.

세그먼테 레지스터에 기준 주소 대신 디스크립터 자료구조의 위치를 설정을 해주며, **디스크립터는 메모리 영역의 정보를 저장하는 자료구조**이다.

그 중 세그먼트 정보를 저장하는 디스크립터를 **세그먼트 디스크립터** 라고 하며, 여기에는 시작 주소, 권한, 크기 등이 저장되어 있다.

<br>

여기에는 디스크립터 특권 레벨(DPL)이 있는데 해당 세그먼트에 접근하기 위한 최소한의 권한이며, 0 ~ 3 사이의 값을 가지고 값이 낮을수록 권한이 높다.

현재 수행 중인 특권 레벨(CPL)이 DPL과 같거나 높아야 세그먼트에 접근할 수 있다.

<br>

**세그먼트 레지스터는 세그먼트 디스크립터의 위치를 가리키며, 세그먼트 디스크립터는 GDT라는 프로세서에 존재하는 자료구조 중 하나에 위치**한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/199916079-e4b55ffc-ac73-448e-8ab0-80b6b0a64578.png)

<br>

세그먼트 디스크립터는 메모리상에 위치하는 자료구조의 일종으로, GDT라고 불리는 곳에 저장되어있다.

GDT는 **연속된 디스크립터의 집합**으로, 최대 8192개의 디스크립터를 저장할 수 있으며, **GDT 역시 메모리에 위치하는 자료구조이므로 프로세서에게 위치를 알려줘야 한다.**

**GDT의 위치와 관련된 레지스터로 GDTR**이 있으며, 16비트의 GDT 크기 필드와 32비트의 기준 주소 필드로 구성되어 있다.

그래서 **프로세서는 세그먼트 레지스터를 통해 어드레스에 접근할 때마다 GDTR를 통해 GDT의 위치를 찾는다.**

<br>

보호 모드 또한 주소를 계산할 때, ```선형(논리) 주소 = 세그먼트 레지스터의 값(기준 주소) + 범용 레지스터 값```이 된다.

계산된 선형주소를 이용해 프로세서는 물리주소를 계산한다.

이 때, 범용 레지스터와 같이 세그먼트 레지스터에 더해질 값은 세그먼트의 크기를 넘을 수 없다.

<br>

![image](https://user-images.githubusercontent.com/52172169/192769860-639b172e-872a-4516-abc3-bcc690aebcf6.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/192771012-e4f44719-88b8-476b-bcc2-dbdeef5a46be.png)

<br>

선형 주소(논리 주소)에서 물리 주소로 변환하는 과정은 우선 선형 주소를 3단계로 구분하는 **3단계 페이징**에 대해 알아야 한다.

보호 모드에서의 페이징은 페이지 크기에 따라 2가지로 구분되는데, **물리 메모리를 4KB 크기로 나누어 선형 주소를 3단계로 구분하는 방식**과, **4MB로 나누어 2단계로 구분하는 방식**이 있다.

두 가지 방법은 페이지 크기와 구분 단계만 다를 뿐, 기본 원리는 같다.

<br>

3단계 페이징은 선형 주소를 ```디렉터리, 테이블, 오프셋``` 세 부분으로 나누며 물리 메모리를 4KB 페이지로 나누어 관리하는 방식이다.

**페이지 디렉터리와 페이지 테이블은 GDT와 마찬가지로 메모리 공간에 있는 자료구조일 뿐**이다.

**각각 페이지 디렉터리와 페이지 테이블에 있는 엔트리의 위치를 나타낸다.**

<br>

선형주소는 최상위 비트부터 **디렉터리 오프셋 10비트**, **테이블 오프셋 10비트**, **페이지 오프셋 12비트**로 구분한다.

디렉터리와 테이블 오프셋이 10비트이므로 **페이지 디렉터리와 페이지 테이블의 엔트리 개수는 2^10 = 1024개이다.**

**페이지 디렉터리 엔트리 값과 페이지 테이블 엔트리 값은 각자 다음에 위치하는 페이지 테이블의 시작 주소와 페이지의 시작 주소를 나타낸다.**

이 값에 선형 주소의 오프셋을 더해 물리주소를 구한다. 그래서 물리 주소로 변환하는 과정은 아래와 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/192771880-f41dc6fc-5e27-4a30-afc4-78b1e9fb18f6.png)

<br>

이 내용들은 OS 구현 시 필수로 알아야되므로, 메모리 관리 기법을 이해하지 못하면 리얼모드에서 보호모드로 전환조차 못한다고 하니 꼭 이해해야 한다고 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

### IA-32e모드 메모리 관리
---

<br>


<br><br>
<hr style="border: 2px solid;">
<br><br>
