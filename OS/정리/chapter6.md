# 32비트 보호모드로 전환하자

<br>

![image](https://user-images.githubusercontent.com/52172169/194505865-dcaa6ec8-e61a-4536-a59c-e5dba44a41b1.png)

<br>

리얼모드에서 보호모드로 전환하는 과정은 6단계를 거친다.

**상위 2단계**는 **보호모드에서 반드시 필요한 자료구조**인 **세그먼트 디스크립터**와 **GDT**를 **생성하는 과정**이다.

두 자료구조는 보호모드로 진입하자마자 참조되므로 미리 설정해줘야 한다.

나머지 하위 4단계는 생성한 자료구조를 프로세스에 설정 및 초기화 하는 단계이다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 세그먼트 디스크립터 생성

<br>

세그먼트 디스크립터는 **세그먼트의 정보를 저장하는 자료구조**로, 크게 **코드 세그먼트 디스크립터**와 **데이터 세그먼트 디스크립터**가 있다.

우리가 만들 mint64 OS는 보호모드의 기본적인 기능만 사용할 예정으로 코드, 데이터 세그먼트만 사용한다고 한다.

<br>

**코드 세그먼트 디스크립터**는 **실행 가능한 코드가 포함된 세그먼트의 정보를 저장**하고 **CS 세그먼트 레지스터에 사용**된다.

**데이터 세그먼트 디스크립터**는 데이터가 포함된 세그먼트 (스택 등)의 정보를 저장하고, CS 세그먼트 레지스터를 제외한 세그먼트 레지스터가 사용할 수 있다.

<br>

보호 모드의 세그먼트 디스크립터는 8바이트로, 다양한 필드가 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194510281-e59ba1b2-0ce6-4d4e-a4ab-faa0d0ec1684.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/194510341-a6b9bf88-ebad-42aa-9cec-411401528632.png)

<br>

우리한테 필요한 정보 즉, 우리가 만들 mint64 OS에서 사용할 세그먼트의 조건은 다음과 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194510450-bd2f8276-932c-403a-a4ab-0e5fcdb8ca62.png)

<br><br>

### 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터 설정
---

<br>

둘을 설정하려면 위의 표를 참조하면, S 필드와 타입 필드를 설정해줘야 한다.

먼저 S는 당연하게도 1로 설정을 해줘야하고, 타입 필드는 아래의 표를 참조하여 의미에 맞게 값을 설정해주면 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194512979-6ccd1c61-0f29-47e4-bd7d-ab3bc144f316.png)

<br>

우리는 기본적인 기능만 필요하므로 **코드 세그먼트는 실행/읽기**, **데이터 세그먼트는 읽기/쓰기**로 설정해줄 것이다.

따라서 타입 필드를 코드 세그먼트는 ```0x0A```, 데이터 세그먼트는 ```0x02```로 설정해준다.

<br><br>

### 세그먼트 영역 설정
---

<br>

MINT64 OS 커널의 세그먼트 디스크립터는 4GB 영역 전체에 접근할 수 있어야 한다.

따라서 **세그먼트의 기준 주소를 0으로 설정**해주고, **크기 필드**는 총 20비트로 나타낼 수 있는 최대 크기가 ```2^20(1MB)```뿐이다.

하지만 **G필드를 1로 설정**해주면 4KB를 곱해주어서 **4GB까지 표현 가능**하다.

<br>

따라서 세그먼트 기준주소는 0, G필드는 1, 크기는 2^20으로 설정해주면 된다.

<br><br>

### 기본 오퍼랜드 크기와 권한 설정
---

<br>

보호모드는 32비트로 동작하므로 오퍼랜드도 32비트로 설정해준다.

**오퍼랜드 크기는 D/B 필드가 담당**하며, **1로 설정**한다.

추가로 IA-32e에서 사용하는 세그먼트의 모드를 설정하는 L 필드가 있는데, 이 값은 0으로 설정해준다.

<br>

**권한**은 **보호모드의 주요 기능 중 하나인 보호 기능의 핵심 역할을 하는 필드**이다.

프로세서는 **세그먼트 디스크립터에 설정된 권한 필드 값과 세그먼트 레지스터의 권한을 비교**하여 **접근 여부를 판단**한다.

mint64 OS는 권한을 따로 구분하지 않기 때문에 DPL 필드를 최상위 값인 0으로 설정해준다.

<br><br>

### 기타 필드 설정
---

<br>

생성한 세그먼트 디스크립터가 보호모드로 전환하는 과정에서 사용되므로 **유효함**을 알려주기 위해서 **P필드를 1로 설정**한다.

mint64 OS에서는 별도의 값을 쓰지 않을 예정으로, AVL 필드는 0으로 설정해준다. 

<br><br>

### 세그먼트 디스크립터 생성 코드
---

<br>

위의 내용들을 어셈블리어 코드로 작성해줘야 하며, 구조는 다음과 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194525495-6c28e931-bb65-4c00-8403-53a0d91c4089.png)

<br>

```nasm
CODEDESCRIPTOR:
    dw 0xFFFF
    dw 0x0000
    db 0x00
    db 0x9A
    db 0xCF
    db 0x00

DATADESCRIPTOR:
    dw 0xFFFF
    0w 0x0000
    db 0x92
    db 0xCF
    db 0x00
```

<br>

**위의 코드로 생성한 디스크립터를 이용해서 GDT 자료구조를 생성**한다.

64비트 IA-32e모드로 가기 위해서는 IA-32e 32비트 모드를 반드시 거쳐야 한다.

우리가 만들 OS는 64비트이므로 32비트 모드는 단순히 잠시 거쳐가는 곳에 불과하므로 64비트 모드로 전환하는데 필요한 기능들에 대해서만 볼 것이라고 한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## GDT 정보 생성

<br>

**GDT(Global Descriptor Table)** 자체는 **연속된 디스크립터의 집합으로, 자료구조가 아니다.**

MINT64 OS에서는 코드 디스크립터와 데이터 디스크립터를 연속된 어셈블리 코드로 나타내면 그 영역이 GDT가 되는 것이다.

주의점은 **GDT의 맨 앞 부분**에는 **널 디스크립터**가 있어야 한다.

**널 디스크립터는 프로세서에 의해 예약된 디스크립터**로, **모든 필드가 0으로 초기화**되어 있으며, 일반적으로 참조되지 않는다.

<br>

GDT는 디스크립터 집합이므로 프로세서에게 자신의 위치를 알려줘야 한다. (프로세서에 GDT의 시작 주소와 크기 정보를 로딩해야 함)

그래서 GDT를 저장하는 자료구조가 필요하며, 구조는 아래와 같다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194551261-465faab0-6d55-46f4-ad89-7a5d1c8e498c.png)

<br>

GDT 자료구조는 데이터 세그먼트의 기준 주소와 관계없이, 어드레스 0을 기준으로 하는 **선형 주소**로, GDT의 실제 물리 주소를 알아야 한다.

먼저 **GDT의 선형주소**는 현재 코드가 실행되고 있는 세그먼트의 시작 주소에서 **오프셋**을 구한 뒤, 세그먼트의 기준 주소를 더해주면 된다.

우리 mint64 OS에서는 코드가 ```0x10000```에서 로딩되어 실행되므로, 오프셋에 ```0x10000```을 더해주면 된다.

<br>

```asm
GDTR:
    dw GDTEND - GDT -1
    dd ( GDT - $$ + 0x10000 )

GDT:
    NULLDescriptor:
        dw 0x0000
        dw 0x0000
        db 0x00
        db 0x00
        db 0x00
        db 0x00

    CODEDESCRIPTOR:
        dw 0xFFFF
        dw 0x0000
        db 0x00
        db 0x9A
        db 0xCF
        db 0x00

    DATADESCRIPTOR:
        dw 0xFFFF
        0w 0x0000
        db 0x00
        db 0x92
        db 0xCF
        db 0x00
GTEND:
```

<br>

이제 보호모드로 전환하는데 필요한 모든 데이터를 준비한 것이다. (2단계까지 완료)

이제 프로세서에 준비된 데이터를 설정 및 초기화 해주면 된다. (나머지 4단계)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 보호모드로 전환

<br>

보호모드로 전환하기 위해서는 3가지만 해주면 된다.

+ GDTR 레지스터 설정
+ CR0 컨트롤 레지스터 설정
+ jmp 명령 수행

<br><br>

### 프로세서에 GDT 정보 설정
---

<br>

```lgdt [GDTR]``` 명령어를 통해 설정할 수 있다.

위의 명령어로 **GDTR 자료구조를 프로세서에 설정하여 GDT 테이블을 로드**한다.

<br><br>

### CR0 레지스터 설정
---

<br>

![image](https://user-images.githubusercontent.com/52172169/194560516-e99e42b8-e574-4be6-a26b-9b1069e239eb.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/194560636-97297d28-106e-4595-a6d2-313bf6b9c07e.png)

<br>

딱 봐도 복잡해보이지만, 우리한테는 대부분 필요없으므로 다음과 같이 설정해주면 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194561378-b9819dec-8d9a-4455-a2ff-7c0d4531315e.png)

<br>

이제 jmp 명령 수행만 남았다.

<br><br>

### 보호모드로 전환과 세그먼트 레지스터 초기화
---

<br>

32비트 코드 ```[BITS 32]```를 준비하고 CS 레지스터를 초기화해줘야 한다.

또한 **CS 레지스터에는** 리얼모드와 달리 보호모드에서는 **GDT 내의 CS 디스크립터의 주소를 넣어줘야 한다.**

이는 **GDT의 시작 주소로부터의 오프셋을 의미**한다.

즉, GDT에서 널 디스크립터 다음에 CS 디스크립터라면 디스크립터는 8바이트이므로 ```0x08```을 넣어주고, 만약 3번째에 있다면 ```0x10(16)```을 넣어주면 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194565795-f535de00-38e9-4081-9b3d-a34b47857e9f.png)

<br>

여기까지 리얼모드에서 보호모드로 전환하는 과정이 끝났다.

위의 내용들을 MINT64 OS에 추가하면 리얼모드에서 보호모드로 전환할 수 있다.

추가로 전환될 때, 전환됬는지 확인하기 위해 출력해주는 함수를 작성해준다.

<br><br>

### 보호모드용 PRINTSTRING
---

<br>

리얼모드용 함수를 보호모드로 전환하는 방법은 간단한데, 스택의 크기가 2바이트에서 4바이트로 바뀌었으며 범용 레지스터가 32비트임을 알기만 하면 된다.

리얼모드의 함수와의 차이점은, 레지스터가 32비트 범용 레지스터로 수정되었고, 4GB 전 영역에 접근가능하므로 리얼모드에서는 별도의 레지스터인 es 레지스터로 접근했지만 보호모드에서는 필요없이 직접 비디오 메모리에 접근할 수 있다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 보호모드용 커널 이미지 빌드와 가상 OS 이미지 교체

<br>

먼저 ```01.Kernel32``` 폴더에 ```Source/EntryPoint.s``` 파일을 생성하여 어셈블리 코드를 작성해준다.

```EntryPoint.s``` 파일은 **보호 모드 커널의 가장 앞부분에 위치한 코드**로, **보호 모드 전환**과 **초기화를 수행**하여 **이후에 위치하는 코드를 위한 환경을 제공**한다.

```EntryPoint```란 외부에서 해당 모듈을 실행할 때, 실행을 시작하는 지점을 뜻한다.

따라서 ```EntryPoint.s```는 부트 로더(외부)에서 보호 모드 커널로 진입하는 부분이므로, 보호 모드 커널의 엔트리 포인트라고 할 수 있다.

<br>

책을 따라 진행해주면 다음과 같이 나온다.

<br>

![image](https://user-images.githubusercontent.com/52172169/194578093-6b5cb4eb-6dd6-4e48-b781-d691a97a7a79.png)

<br>

저자 챕터6 코드 : https://github.com/kkamagui/mint64os-examples/blob/master/source_code/chap06

<br><br>
<hr style="border: 2px solid;">
<br><br>
