# 플로피 디스크에서 OS이미지를 로딩하자

OS 이미지를 메모리로 복사하는 과정을 구현해본다.

<br><br>

## BIOS 소프트웨어와 인터럽트

<br>

BIOS는 **인터럽트 벡터 테이블 (IVT)에 사용할 함수의 주소를 저장**하여, **소프트웨어 인터럽트 (SWI)를 발생시켜 호출**한다.

**IVT는** 메모리 주소 0에 있는 테이블로, **특정 번호의 인터럽트가 발생하면 인터럽츠 처리 함수를 검색하는 용도로 사용**된다.

**테이블의 각 항목은 각 인덱스에 해당하는 인터럽트를 처리하는 함수의 주소가 저장**되어 있고, 크기가 4바이트이다.

인터럽트는 최대 256개까지로, 리얼모드의 IVT 크기는 1024바이트이다.

<br>

BIOS가 제공하는 디스크 서비스는 index 값이 ```0x13```이다.

그래서 디스크 서비스 사용 시 ```int 0x13```으로 호출해줘야 한다.

또한 서비스 이용 시 함수를 호출하는 것이므로 인자를 넘겨주거나 받아야 하는데, 이를 레지스터가 수행해준다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## OS 이미지 로딩 기능 구현
### 디스크 읽기 기능 구현

<br>

mint64 OS의 이미지는 부트로더, 보호모드 커널, IA-32e 커널로 구성되고, 각각 하나의 섹터를 담당하여 하나의 이미지로 합쳐진다.

그래서 **두 번째 디스크 섹터부터 읽어서 특정 메모리로 복사해주면 이미지 로딩은 끝난다.**

그래서 mint64 OS는 OS이미지를 ```0x10000(64KB)```에 로딩해서 실행한다. 

물론 ```0x7C000```(부트 로더) 다음에 연속해서 OS를 복사해도 실행되는데 문제는 없다.

<br>

플로피 디스크의 첫 번쨰 섹터는 부트로더가 되며 BIOS가 메모리에 적재하고, **2번째 섹터부터 OS이미지 크기만큼 읽어서 복사한 뒤 메모리에 적재하면 된다.**

자세한 코드는 책에서 확인하기

<br><br>
<hr style="border: 2px solid;">
<br><br>

### 스택 초기화

<br>

4장에서 했던 메시지 출력을 함수로 구현하여 호출할 것이다.

스택과 관련된 레지스터는 Stack Segment Register (SS), Base Pointer Register (BP), Stack Pointer Register (SP)가 있다.

**SS는 스택 영역으로 사용할 범위(기준 주소)를 결정**한다.

**BP는 스택의 기준 주소를 임시로 저장하는 역할**을 하고, **SP는 스택의 최상위를 가리키는 역할**을 한다.

<br>

16비트 모드는 세그먼트 크기가 최대 ```2^16(64KB, 0x10000)```이므로, SS가 ```0x0000```이면 **스택으로 사용 가능한 영역**은 ```0x00000 ~ 0x0FFFF```가 된다.

물론 **범위가 실제 스택의 크기가 되는 것은 아니며, 스택의 크기는 BP, SP의 초기값으로 결정**한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/193410837-287b262f-844e-48b3-b6bd-cd2574938167.png)

<br>

위의 사진을 참조하여 함수가 호출이 되면, 호출된 함수 안에서 정형화된 코드가 있다.

```push bp, mov bp,sp```인데, 이는 곧 위의 사진으로 확인하면 기존 bp 값을 스택에 삽입하고 함수가 호출된 직후의 sp 값을 해당 함수의 bp로 설정하는 것이다.

이렇게 함으로써 기존 bp에서 사용하던 오프셋을 똑같이 사용할 수 있다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

### 보호모드에서 사용하는 함수 호출규약

<br>

+ stdcall
  + 인자를 스택에 저장 (오른쪽에서 왼쪽 순으로)
  + 호출된 쪽에서 스택을 정리
    + 인자가 3개라면 해당 함수에서 ```ret 12``` (보호모드이므로 32비트임)

<br>

+ cdecl
  + 인자를 스택에 저장 (오른쪽에서 왼쪽 순으로)
  + 호출한 쪽에서 스택을 정리
    + 인자가 3개라면 함수 끝난 후 ```add esp, 12``` 

<br>

+ fastcall
  + 일부 인자를 레지스터에 저장
  + 호출된 쪽에서 스택을 정리
  + IA-32e는 fastcall를 확장한 방식을 사용함

<br><br>
<hr style="border: 2px solid;">
<br><br>

### 최종 부트로더 소스코드

<br>

그래서 위의 내용을 토대로 작성하여 최종적으로는, **부트로더가 실행되면 부트로더의 역할에 따라 OS 이미지를 메모리에 적재(로딩)**하여 OS 이미지가 정상적으로 로딩되었다면 ```0x10000``` 위치로 이동하여 보호 모드 커널이 실행되도록 하였다.

<br>

최종 부트로더 코드를 작성해주면 이제 거의 다 준비가 된 상태이다.

부트로더는 OS이미지를 메모리에 적재하는 역할을 하기 때문에 우리는 가상의 OS 이미지가 필요하다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 테스트를 위한 가상 OS이미지 생성

<br>

교재를 따라서 작성을 해주면 에러가 발생하는 기이한 현상을 볼 수 있다.

아래의 사이트처럼 나올 것이다.

http://jsandroidapp.cafe24.com/xe/index.php?mid=qna&search_target=title&search_keyword=5%EC%9E%A5&document_srl=11322

<br>

해당 사이트에 해결 방법이 있지만 더 자세히는 http://jsandroidapp.cafe24.com/xe/development/12035에 있다.

따라서 해당 코드 부분을 수정을 해주면 해결된다..

<br>

![image](https://user-images.githubusercontent.com/52172169/193450008-fa922fb4-df12-4cd5-8186-3af143ef35e1.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
