# 키보드 디바이스 드라이버를 업그레이드 하자

<br>

키보드 디바이스 드라이버를 인터럽트 기반으로 업그레이드 하고, 데이터 전달 역할을 하는 큐를 생성하여 인터럽트 핸들러에서 셸 코드로 키 정보를 전달하는 방법을 살펴본다.

현재 방식은 프로세서가 컨트롤러를 주기적으로 확인하여 키 값을 얻어서 처리를 해야 하는데, 이를 인터럽트 방식으로 바꾸는 것이다.

즉, 키를 입력하면 인터럽트가 발생하면서 인터럽트 핸들러가 키 값을 읽어서 버퍼(큐)에 저장하면, 프로그램(셸)이 버퍼(큐)에서 값을 읽어서 출력을 해주게끔 변경해줄 것이다.

<br>

기존의 키보드 컨트롤러에서 값을 읽는 방식과 큐에서 값을 읽는 것의 차이가 있는지 생각이 들 수 있는데, 외부에 있는 컨트롤러에서 데이터를 확인하는 것보다 메모리에서 데이터를 읽어오는 것이 훨씬 빠르므로 더 유용하다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 인터럽트 핸들러와 큐

<br>

키 정보를 받을 버퍼를 만들어주는데 바로 원형 큐 형태로 만들어 줄 것이며, 이 버퍼 큐는 단순히 키 정보를 받기 위한 용도가 아닌 범용으로 다양하게 mint64 os에서 사용할 예정이다.

그리고 버퍼에서는 1바이트씩 처리하지 않고 3바이트씩 자료구조 형태로 묶어서 처리한다.

<br>

코드 자체는 원형 큐 구현 코드와 거의 같다.

주의할 점이라고는 버퍼에 접근할 때, 초기화 해줄 때의 큐의 데이터 크기를 이용해서 접근해야 한다는 것이다.

만약 3바이트로 초기화해줬다면 인덱스가 4일 때, 실제로 데이터가 위치한 버퍼의 바이트 오프셋은 12바이트이므로 여기로 접근해줘야 한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/198940744-f17dd543-581b-4770-bb03-07021e99791b.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 키보드 디바이스 드라이버 업그레이드

<br>

위에서 만든 큐는 **태스크와 인터럽트 핸들러를 연결하는 큐이자 범용적으로 사용할 큐**이다.

멀티태스킹 환경에서는 여러 태스크끼리 CPU를 나누어 사용하므로 인터럽트에서 수신된 데이터를 처리하기 전까지는 따로 저장해둘 공간이 필요한데, 이 또한 큐로 만들어 줄 것이다.

즉, **이번에 만드는 큐는 키 정보를 저장하는 큐**이다. (물론 큐 자체는 위에서 정의한 범용 큐를 이용한다)

<br>

키보드 핸들러가 큐에 데이터를 넣고 셸 코드가 이 큐에서 데이터를 꺼내 사용할 것이다.

그럴러면 전달된 키를 셸 코드에서 처리하려면 최소한 **해당 키의 스캔코드 값과 이를 아스키 값으로 변환할 자료구조가 필요**하다.

그래서 스캔코드 값을 담을 변수와 아스키 값을 담을 변수 및 flag 변수가 포함된 자료구조를 생성한다.

<br>

지금까지의 핸들러의 역할은 메시지를 화면에 출력하고 EOI만 전송해줄 뿐이었지만, 이제 키를 읽어서 큐에 삽입하는 역할을 부여해 줄 것이다.

또한 main.c에 있던 셸 코드 또한 수정해주어서 큐에서 데이터를 가져오도록 수정해준다.

<br>

단, 인터럽트 기반으로 업그레이드를 하면 문제점이 2가지가 있다고 한다.

첫 번째는, ```1) 큐가 가득찬 상태에서 제거 명령을 수행```하는데 제거 후 제거라는 플래그 설정 직전에 ```2) 큐에 데이터를 삽입하는 인터럽트가 발생```하였다.

그러면 순차적으로 진행이 되었다면 ```1) 제거가 되고 제거 플래그 설정```된 후 ```2) 인터럽트로 데이터 삽입 후 삽입 플래그 설정```이 되므로 큐 상태는 가득찬 상태이며 그렇게 인식이 될 것이다.

그러나 아니라면 **인터럽트를 처리하면서 설정된 삽입 플래그**가 **인터럽트 처리 후 복귀하면서 못다한 제거 플래그를 설정**하게 되므로 **큐는 가득차 있는데 제거 플래그**인 상태가 된다.

즉, 비어 있다고 인식이 되는 것이다.

<br>

두 번째는, 키보드에 제어 명령을 보낸 후 ACK를 받기 전까지 기다리는 시간 동안에 인터럽트가 발생하여 ACK를 대신 처리하게 되는 문제점이 발생할 수 있다.

**두 문제 모두 인터럽트가 발생하지 않아야 되는 시점에 발생하는 것이 문제점**이므로 해결방법은 해당 구간에서 인터럽트가 발생하지 않도록 인터럽트를 제어해주면 되는 것이다.

이상적인 방법으로는 **인터럽트의 이전 상태를 저장해두었다가 복원**해주는 방법이다.

<br>

그래서 큐에 데이터를 삽입 또는 삭제할 때 인터럽트 플래그를 조작하여 작업 수행동안에는 발생하지 않도록 코드를 수정해주었다.

ACK 부분은 **ACK를 기다리는 동안 다른 키가 수신될 수 있으므로 이를 ASCII 값으로 변환하여 큐에 삽입해주는 부분**과 **인터럽트를 비활성화 하는 부분**을 고려해줘야 한다. 

이제 코드를 짜서 통합 후 빌드를 해준다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 업그레이드 및 빌드

<br>

범용 큐를 정의한 ```Queue.c, Queue.h```, 인터럽트를 제어하는 함수인 SetInterrupt를 ```Utility.c```에 정의를 해주고, 다른 코드들을 조금씩 수정해주었다.

<br>

![image](https://user-images.githubusercontent.com/52172169/199017678-f95a36e1-f711-4ab1-9a75-e6f917aeca6c.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
